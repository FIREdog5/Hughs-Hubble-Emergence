public static void drawGlobe(ImageResource image, float radius, float x, float y) {
  GL2 gl = ClientMain.gl;

  Texture texture = null;

  if (image != null) {
  texture = image.getTexture();
  }

  if (texture == null) {
    texture = ImageResources.error.getTexture();
  }

  gl.glBindTexture(GL2.GL_TEXTURE_2D, texture.getTextureObject());

  int currentFrame = (int) (frame / image.getFrameDelay()) % image.getFrames();

  if (image.getLoops()) {
    if ((int)(frame / image.getFrameDelay()) % (image.getFrames() * 2) >= image.getFrames()) {
      currentFrame = image.getFrames() - currentFrame - 1;
    }
  }

  float frameBase = 1f / image.getFrames() * currentFrame;
  float frameTop = 1f / image.getFrames() * (currentFrame + 1);

  float textureDim = frameTop - frameBase;

  float rotBase = (frame % image.getFrameDelay()) / (float)image.getFrameDelay() * 0.5f;
  float rotTop = 0.25f;

  //
  // int colorFlipper = 0;
  //

  float increment = (float) Math.ceil(radius);
  float jInc = .1f;

  float rotFrame = (float)(rotTop / (2f * radius));

  for(float c = -radius; c < radius; c+= jInc) {
    jInc = Math.max(((-1 * c * c / radius + radius) / 3), .1f);
    if (c > radius) {
      c = radius;
    }
    float j1 = c;
    float j2 = Math.min(c + jInc, radius);
    //
    // colorFlipper++;
    // colorFlipper %= 2;
    //
    float[] yCoords = {j1 + y, j1 + y, j2 + y, j2 + y};
    float quadBase = frameBase + (float)(frameTop / (2 * radius)) * (float)(-j1 + radius);
    float quadTop = frameBase + (float)(frameTop / (2 * radius)) * (float)(-j2 + radius);

    float i1Inc = (float)Math.sqrt(radius * radius - j1 * j1) / radius;
    float i2Inc = (float)Math.sqrt(radius * radius - (j2) * (j2)) / radius;
    for(float i = -radius; i < radius - .001f; i+=radius / increment) {
      //
      // if(colorFlipper == 1){
      //   Graphics.drawColor(new Color("#ff0000"));
      // } else {
      //   Graphics.drawColor(new Color("#00ff00"));
      // }
      // Graphics.drawColor(new Color("#ffffff"));
      // colorFlipper++;
      // colorFlipper %= 2;
      //
      float i1 = i * i1Inc;
      float i2 = (i + radius / increment) * i1Inc;
      float i3 = (i + radius / increment) * i2Inc;
      float i4 = i * i2Inc;
      float[] xCoords = {i1 + x, i2 + x, i3 + x, i4 + x};

      float quadLeft = rotBase + rotFrame * (float)(i + radius);
      float quadRight = rotBase + rotFrame * (float)(i + radius / increment + radius);
      float[] uCoords = {quadLeft, quadRight, quadRight, quadLeft};
      float[] vCoords = {quadBase, quadBase, quadTop, quadTop};
      drawQuadWithBoundTexture(xCoords, yCoords, uCoords, vCoords);
    }
  }
  gl.glBindTexture(GL2.GL_TEXTURE_2D, 0);
}

public static void drawQuadWithBoundTexture(float[] xCoords, float[] yCoords, float[] uCoords, float[] vCoords) {
  GL2 gl = ClientMain.gl;

  gl.glBegin(GL2.GL_QUADS);
  {
    gl.glTexCoord2f(uCoords[0], vCoords[0]);
    gl.glVertex2f(xCoords[0], yCoords[0]);
    gl.glTexCoord2f(uCoords[1], vCoords[1]);
    gl.glVertex2f(xCoords[1], yCoords[1]);
    gl.glTexCoord2f(uCoords[2], vCoords[2]);
    gl.glVertex2f(xCoords[2], yCoords[2]);
    gl.glTexCoord2f(uCoords[3], vCoords[3]);
    gl.glVertex2f(xCoords[3], yCoords[3]);
  }
  gl.glEnd();
  gl.glFlush();
}
